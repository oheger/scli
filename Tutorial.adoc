:toc:
:toc-placement!:
:toclevels: 3
= SCLI Tutorial

This document describes the features of the SCLI library in form of usage
examples, starting from easy ones and advancing to more complex scenarios.
Most of the examples do not build upon each other; so you might directly
proceed to the section you are interested in the most.

NOTE: While not strictly necessary, it is helpful to understand the underlying
concepts used by SCLI before browsing the usage examples in this document. They
are described in the link:README.adoc[README document].

toc::[]

== Introduction

This document describes the usage of the SCLI library based on an imaginary
command line interface application called _transfer_. _transfer_ can download
or upload a number of files from or to a server. It supports a number of
options to configure the data transfer; for instance, it is possible to encrypt
data, to set timeouts, or to enable a _dry-run_ mode. For the server, which is
the target of the transfer operation, the application supports multiple
transfer protocols; depending on the protocol selected, different additional
parameters are expected. So if the target server uses the HTTP protocol, the
user needs to provide credentials for _basic auth_ authentication.

The general command line for our hypothetical _transfer_ application looks as
follows:

`transfer [options] <command> <file1> [<file2>..<fileN>] <serverUri>`

_<command>_ can be either `upload` or `download` and determines the direction
of the data transfer. After the command, an arbitrary number of file paths to
be transferred are listed; but there must be at least one file. The last
argument is the URI of the server, which is the target of the transfer. The
_spec_ of this URI is evaluated to determine the server type. The server type
influences the set of parameters accepted by the application; options
configuring an HTTP server are only accepted if the server type is actually
HTTP.

== Sample code

Most of the code examples used throughout this document are taken from the
link:./src/test/scala/com/github/scli/sample/transfer/TransferParameterManager.scala[TransferParameterManager]
module. It defines the data structures to represent the arguments accepted by
the _transfer_ application and declares extractors to actually process the
arguments. For your own applications, you can follow a similar pattern to keep
the logic of command line processing in a dedicated parameter manager class.

When you inspect the _TransferParameterManager_ source code, you will see a
number of case classes ending on the suffix _Config_ that are representations
of the command line arguments accepted by the sample application. The top-level
case class is _TransferCommandConfig_; a successful processing of the command
line yields an instance of this class. With such an object available, the
application has direct and type-safe access to the arguments provided by the
user. The examples in this document show how the single arguments are read from
the command line, processed, and eventually stored in those config objects.

There is also a test class for the _TransferParameterManager_ module, using the
_transfer_ sample application to test the library against a realistic use case:
link:./src/test/scala/com/github/scli/sample/transfer/TransferParameterManagerSpec.scala[TransferParameterManagerSpec].
Use this class as a source for ideas how to test your own command line
processing logic based on the SCLI library.

== Usage examples

This section contains many code examples showing SCLI in action to process the
command line of the _transfer_ sample application.

=== Basic extractors

In order to read the values of arguments from the command line and convert them
to a suitable representation, the developer has to define extractors. This
subsection demonstrates the domain specific language offered by SCLI for the
definition of basic extractors.

The functions used within this section are defined by the _ParameterExtractor_
module. So they require this import:

`import com.github.scli.ParameterExtractor._`

NOTE: The DSL provided by SCLI is implemented using Scala _implicit functions_,
which are also defined by the `ParameterExtractor` class; the wildcard import
above makes sure that these functions are available in the current scope.

==== Extracting a single string option value

One entry point into extracting the values of options is the _optionValue()_
function. It returns a _CliExtractor_ of type _SingleOptionValue[String]_. This
can be the basis for further data type conversions. The function expects the
key of the option as argument. It assumes that the option can have at most
one value (which is reflected by the result type). This should be the most
typical use case.

One example of such an option in the sample application is the `tag` option.
It allows the user to specify a label to be assigned to the transfer operation.
The assignment only happens if the option is present:

 transfer --tag "v1.1.2" upload ./source /target

This use case is actually handled by the most basic extractor:

[source,scala]
----
val extTag = optionValue("tag")
----

This extractor yields an `Option[String]`, which corresponds to the basic
`SingleOptionValue[String]` type; it fails if the option occurs multiple times
and thus has more than one value.

NOTE: Actually, `SingleOptionValue[String]` corresponds to a
`Try[Option[String]]`. Extractors typically return `Try` types because
transformations on the user input can always fail. When combining the results
of extractors failed extractions are detected and collected into a meaningful
error message.

==== Extracting an option with multiple string values

The _transfer_ sample application supports the command line option `log` to
define lines for the transfer log. The option can occur multiple times to
generate multiple log entries, as in the following fragment:

 transfer --log "Updating sources" --log "Version 1.1.2-2020-06-28" \
    --log "by test.user@scli.org" upload ./source /target

The type of the `log` option is `Iterable[String]`, which corresponds to the
basic `OptionValue[String]` type. For the creation of extractors of this type,
the _multiOptionValue()_ function is responsible. Its signature is analogous to
the one of the _optionValue()_ function:

[source,scala]
----
val extLog = multiOptionValue("log")
----

Except for the different result type, extractors created by the functions
_optionValue()_ and _multiOptionValue()_ are very similar in the features they
support; a common set of transformations is available for both. We will discuss
such transformations later in this tutorial.

==== Extracting an option with a mandatory string value

Some parameters must always be present for the application to fulfill its
function. In the _transfer_ application, if the target is an HTTP server, the
user must provide the credentials for basic auth - a user name, and a password.

To indicate that an extractor yields a single, mandatory value, it needs to be
decorated with the `mandatory` modifier. This is actually a difference between
extractors for single option values (constructed via `optionValue()`) and those
for multi option values (created by `multiOptionValue()`): `mandatory` only
works for single values. The modifier changes the result type of the extractor
from `Try[Option[String]]` to `Try[String]`. The extractor produces a failure
if no value is present for this argument. The following snippet shows the
declaration of the extractor for the user name for the HTTP server:

[source,scala]
----
val extUsr = optionValue("user")
  .mandatory
----

==== Extracting the value of a switch

The basic extractors discussed so far have been concerned with options. Another
frequently used element on the command line is a switch. Switches do not get a
value assigned, but their presence or absence on the command line determines
their value. As their value can only be one of two distinguished states -
present or absent -, it is represented as a Boolean.

To declare a switch parameter, SCLI offers the `switchValue()` function. The
function expects at least the key of the switch parameter to be passed in. Its
result is a `CliExtractor` producing a value of type `Try[Boolean]`.

The _transfer_ sample application defines a couple of switch parameters. For
instance, when uploading files to a server the user can control whether hashes
should be uploaded for the files processed, or whether files that were uploaded
successfully should be removed locally. Both of these features are disabled per
default; the user can activate them by passing the corresponding switch
parameters on the command line:

 transfer upload data.txt http://target.server.org/ --upload-hashes --remove-uploaded-files

Note that switches on the command line look similar to options, but they do not
have any value. The following code fragment shows the declaration of these two
switch parameters:

[source,scala]
----
val extUploadHashes = switchValue("upload-hashes")
val extRemoveUploaded = switchValue("remove-uploaded-files")
----

The resulting `CliExtractor` objects are nothing special; they can be further
transformed or combined in the same way as the extractors produced by the
`optionValue()` function.

==== Adapting the boolean value of a switch

In most cases - including the examples from the previous subsection - the value
of a switch should be interpreted as *true* if the corresponding parameter
appears on the command line. There are, however, exceptions to this rule. So it
could be the case that the data model used by the application to represent its
parameters is not fully aligned with the command line interface visible to the
user. We have constructed such a case in the _transfer_ sample application in
the configuration of download operations: it contains a flag whether local
files should be overridden:

[source, scala]
----
case class DownloadCommandConfig(targetFolder: Path,
                                 overrideLocalFiles: Boolean) extends CommandConfig
----

Per default, this flag is *true*, as newer files from the server should always
replace local files. So an invocation of:

 transfer download data.txt http://target.server.org --target-folder /data

will download the file `data.txt`, even if it is already existing in the target
folder. The user should now have the option to change this behavior by
specifying a switch parameter:

 transfer download data.txt http://target.server.org --target-folder /data --skip-existing

So if the `skip-existing` switch is present, the extractor should yield the
value *false*, causing the download of `data.txt` to be skipped if the file is
available locally. Basically, the logic of the evaluation of the switch is just
inverse: the presence of the switch should yield a result of *false*, while its
absence is interpreted as *true*.

This behavior is easily achieved by passing an additional flag value to the
`switchValue()` function. The function supports a boolean parameter
_presentValue_ controlling the value to assume when the switch is present.
Using this mechanism, the declaration of the extractor for the `skip-existing`
parameter looks as follows:

[source,scala]
----
val extOverride = switchValue("skip-existing", presentValue = false)
----

==== (Short) Alias names

User-friendly command line applications often support abbreviations for their
switches and option names. Per default, parameters have a descriptive name,
which can be used for instance in shell scripts to make their meaning explicit;
but for the user typing in commands in a terminal, it is easier to use short
names to reduce the amount of typing. Convention is that long parameter names
use the prefix `--` while short aliases are prefixed only with a single `-`.
The _transfer_ demo application wants to support its users in this way and
therefore defines a number of aliases for its options and switches. For
instance, the following command lines are equivalent:

 transfer upload --log "Updated file" file.txt --tag "v10" /shared/data \
   --chunk-size 16384 --timeout 30 --dry-run

and

 transfer upload -l "Updated file" file.txt -T "v10" /shared/data -s 16384 -t 30 -d

Defining a short alias name for an option or switch is straight-forward: just
use the `alias()` function on a `CliExtractor`. Below are some examples taken
from the code of the demo application:

[source,scala]
----
val extChunkSize = optionValue("chunk-size")
  .toInt
  .fallbackValue(DefaultChunkSize)
  .mandatory
  .alias("s")
val extTimeout = optionValue("timeout")
  .alias("t")
  .toInt
  .mapTo(t => t.seconds)
val extLogs = multiOptionValue("log")
  .alias("l")
val extTag = optionValue("tag")
  .alias("T")
val extDryRun = switchValue("dry-run")
  .alias("d")
----

Note that it does not matter where in the chain of modifiers the `alias`
function appears; it is available on all extractors independent on their data
type. (This includes extractors for input parameters, although the alias has no
effect in this case.)

Per default, the key passed to the `optionValue()` and `switchValue()`
functions is considered the long parameter name, while the `alias()` function
sets a short key. This is not enforced though; the functions accepting a
string-based key also support a boolean parameter named _shortAlias_; passing
in *true* or *false* here gives full control over the interpretation of the
key.

There is no restriction in the number of aliases that can be set for a
parameter. The typical use case is to have at most one long key and one short
alias, but the developer is free to define multiple alias, which can be both
short or long keys. One use case could be a new version of an application that
has renamed a parameter because the old name may have been misleading. To
remain backwards compatibility, the old deprecated name could be used as an
alias for the new name:

 val extractor = optionValue("new-key")
   .alias("n")
   .alias("old-key", shortAlias = false)

NOTE: Parameter aliases are processed already in the parsing phase. That means
that the map with parameters passed to extractors contains only the standard
parameter keys.

=== Input parameters

Input values are elements on the command line that cannot be assigned to
options. The _transfer_ sample application uses the following parameters of
this type (in this order) - refer to the <<Introduction>> section for further
details:

* A command that determines the direction of the transfer
* A sequence of paths to be transferred
* The URI of the target server

This set of input parameters demonstrates a number of use cases:

* Input parameters typically get their meaning from their position on the
  command line. The application specifies that the first parameter is the
  transfer command, while the last is the server URI. Note that other options
  can appear between input parameter values; they are ignored when extracting
  the values of a specific input parameter.
* Like options, input parameters can have either a single or multiple values.
  Input parameters with multiple values make the positioning more complicate:
  If the exact number of values for a parameter is not known (as is the case in
  the sample application for the number of paths to transfer), specifying
  absolute parameter indices is no longer possible.
* Despite from their special syntax, the values of input parameters should be
  accessible in the same way as option values; for instance, transformations
  on values should be possible.

We will demonstrate how SCLI addresses these use cases.

==== Extracting an input parameter with a single value at a specific position

For the creation of extractors for input parameters, the SCLI library offers a
pair of functions analogously to `optionValue()`, and `multiOptionValue()`:
`inputValue()` produces an extractor for an input parameter with a single
value; extractors generated by `inputValues()` in contrast support multiple
values.

In the _transfer_ sample application, the easiest input parameter is the first
one, the transfer command. Its position on the command line is known exactly.
The `inputValue()` function expects this position as the only mandatory
parameter. Parameter indices are 0-based; so the following code fragment
produces an extractor for this input parameter:

[source,scala]
----
val extCommand: CliExtractor[SingleOptionValue[String]] = inputValue(0)
----

Input parameters do not necessarily need a key like options; it is, however,
recommended defining one, as these keys appear in error or usage messages. If
the developer does not define a key, SCLI generates a synthetic key based on
the parameter index. To define a key explicitly, pass the _optKey_ parameter
to the function (it is an `Option`, which is `None` per default):

[source,scala]
----
val extCommand = inputValue(optKey = Some("transferCommand"), index = 0)
----

==== Extracting an input parameter with multiple values

To deal with input parameters with multiple values, there is the
`inputValues()` function. In contrast to `inputValue()`, it does not take a
single parameter index, but a pair of _fromIndex_ and _toIndex_. Like the
index parameter for `inputValue()`, these indices start with 0. Both are
inclusive. So if you want to assign the first three input values to a
parameter, you have to set the _fromIndex_ to 0 and the _toIndex_ to 2.

For the files to transfer in the sample application, we have the problem that
the exact number of parameter values is unknown; the user can provide an
arbitrary number of paths. So how to set the _toIndex_ parameter?

To deal with such use cases, there is the possibility to specify negative index
values. A negative index is interpreted from the end of the command line: The
index value -1 references the last input parameter; the index -2 the second
last, etc.

In the _transfer_ application, the list of files to transfer starts from the
second input value (after the transfer command) and goes to the one before the
last; the last one is the URI of the server. So the indices to specify are
_fromIndex_ = 1 and _toIndex_ = -2. Here is the code fragment that constructs
the extractor for the _transferFiles_ parameter:

[source,scala]
----
val extSrcFiles: CliExtractor[OptionValue[String]] =
  inputValues(fromIdx = 1, toIdx = -2, optKey = Some("transferFiles"))
----

Now for the last remaining input parameter, the server URI, we can use the same
trick. As it is the last parameter, we simply set the index to -1, resulting
in:

[source,scala]
----
val extServerUri = inputValue(optKey = Some("serverUri"), index = -1)
  .mandatory
----

==== Defining the multiplicity of parameters

There is still a problem with the definition of the input parameter for the
files to transfer: The current declaration states that the parameter values are
in the range from the second to the second last parameter value. This could
yield an empty list of values if the command line contains only the transfer
command and the server URI. The application logic, however, requires at least
one file to be present.

Single-valued parameters support the `mandatory` modifier to declare that a
value is required. For parameters with multiple values, there is a means
allowing even more control over the exact number of values supported: the
`multiplicity` modifier. The modifier takes up to two parameters for the
minimum and maximum number of parameter values. If a bound is unspecified, this
means that there is no restriction in this direction. The default multiplicity
assumed for a multi-valued parameter is `0..\*` - an arbitrary number of values
is allowed. For the _transferFiles_ parameter we have to change this to
`1..*`, so that at lest one value must be provided. To do this, we extend the
declaration of the parameter as in the following fragment:

[source,scala]
----
val extSrcFiles = inputValues(fromIdx = 1, toIdx = -2, optKey = Some("transferFiles"))
  .multiplicity(atLeast = 1)
----

Now the extractor generates a failure if no file to transfer has been passed
in.

NOTE: The `multiplicity` modifier has been introduced in the context of
input parameters; but it is supported by all kinds of parameters with multiple
values.

=== Type conversions

While the command line passed to an application is a list of strings, the
single parameter values may have different data types in the logic of the
applications. In the _transfer_ sample application, the list of files to
transfer should actually contain `java.nio.file.Path` objects; there is another
parameter to define a chunk size for the transfer, which is actually an integer
number.

SCLI supports a standard set of data type conversions for both extractors for
single-valued and multi-valued parameters. In addition, there is a mechanism
to apply arbitrary conversion functions.

Type conversions may fail. For instance, if the user passes the string _LARGE_
to the _chunkSize_ option, the conversion to `Int` will throw an exception.
Such exceptions are caught during parameter processing and recorded as failures
that can be displayed to the user.

==== Extracting an Int parameter

One of the conversion functions available out of the box is `toInt`. Like all
of these conversions, it is applicable to extractors yielding a String type.
The resulting extractor then produces a value of type `Int`.

The sample application, applies this conversion to the already mentioned
_chunkSize_ option:

[source,scala]
----
val extChunkSize: CliExtractor[SingleOptionValue[Int]] = optionValue("chunk-size")
  .toInt
----

==== Extracting a Path parameter

For the input parameter for the files to transfer, the values need to be
converted to `Path` objects. This is done analogously to the integer conversion
by using the `toPath` conversion function. (As you see, it does not make any
difference whether the extractor produces a single or multiple values; the
conversion functions are available in both cases.)

[source,scala]
----
val extSrcFiles: CliExtractor[OptionValue[Path]] =
  inputValues(fromIdx = 1, toIdx = -2, optKey = Some("transferFiles"))
    .multiplicity(atLeast = 1)
    .toPath
----

==== Extracting a Boolean parameter

Another conversion function available out of the box is `toBoolean`, which, not
surprisingly, converts parameter values to the type Boolean. It does this by
evaluating the string value and expecting one of the strings *true* or *false*;
result is the corresponding Boolean value, any other value causes the extractor
to produce a failure.

So this conversion function is rather restrictive. One way to make it more
lenient is allowing different case for the parameter values - so that input
like *True* or *FALSE* is still accepted. For such use cases, SCLI supports the
`toLower` function which converts the value(s) of a parameter to lower case.
This function can now be applied before the `toBoolean` conversion:

[source,scala]
----
val extBoolean: CliExtractor[SingleOptionValue[Boolean]] = optionValue("flag")
  .toLower
  .toBoolean
----

NOTE: An alternative to a type conversion to Boolean can be
<<Extracting the value of a switch,switches>>. Here the presence or absence of
the switch in the command line determines whether the value is *true* or
*false*. This can be more convenient for the user who is not forced to enter
the correctly spelled string values.

==== Extracting an enum parameter

Sometimes the value(s) of a parameter must belong to a defined set of allowed
constants. A possible use case is selecting a specific mode of the application.
The _transfer_ sample application supports a parameter to set the mode for
encrypting files during the transfer. Here multiple options are available:
Encryption can be disabled, the content of the files can be encrypted, or
encryption can be applied to both the content and the file names.

The conversion function to deal with such cases is `toEnum`. The function is
not limited to Java enum classes as the name might suggest. It rather expects a
mapping function, which converts the original string value to a target value.
The function actually returns an `Option` of the target value; a result of
`None` means, that the string value could not be matched to a valid enumeration
literal. This causes the extractor to produce a failure.

The _transfer_ application needs to map strings to constants of the `CryptMode`
class. `CryptMode` is actually a Scala enumeration class as shown below:

[source,scala]
----
object CryptMode extends Enumeration {

  val None, Files, FilesAndNames = Value

  final val Literals: Map[String, CryptMode.Value] =
    values.map(v => (v.toString.toUpperCase(Locale.ROOT), v)).toMap
  }
----

The class defines a number of constants representing the valid modes for
encryption. It also has a map allowing access to constants by their name; the
keys in this map are in upper case. The extractor for the encryption mode uses
this map for the mapping of input strings to `CryptMode` constants:

[source,scala]
----
private def cryptModeExtractor: CliExtractor[SingleOptionValue[CryptMode.Value]] =
  optionValue("crypt-mode")
    .toUpper
    .toEnum(CryptMode.Literals.get)
----

Note how the _get()_ function of the map with `CryptMode` literals is passed as
mapping function to the `toEnum` converter. `Map.get()` in this case is a
function of type `String => Option[CryptMode.Value]`, which is the exact
signature required by `toEnum`. This is a good example of the flexibility
allowed by the approach with the mapping function.

Note further the usage of the `toUpper` conversion function before applying
`toEnum`. `toUpper` is the counter-part of the `toLower` converter we already
met. It converts the current parameter value to upper case. This is needed in
this case because the keys in the map accessed by the mapping function are in
upper case as well.

==== Applying a custom mapping function

Extractors, being monads, support operations like _map()_ or _flatMap()_
natively to transform the values they produce. However, given the data types
the extractors typically operate on, using these operations is rather
inconvenient. The mapping functions expected by them have to deal with
Iterables or Options nested in Tries.

To simplify custom mapping, SCLI therefore offers the `mapTo` converter. It
expects a mapping function that directly operates on the option values. This
function is called only if the result of the extractor is successful, and a
value is actually present.

The _transfer_ sample application uses this feature to extract the `timeout`
option. The user can here specify an Int value, which is interpreted as the
timeout for a transfer operation in seconds. The data type of the value of
this option is `Option[Duration]` (as it is not required to provide a timeout).
The code fragment below shows the declaration of the extractor for the
`timeout` option. It converts the value of the option to the type `Int` first
and then applies a custom mapping function to transform the result to a
`Duration`:

[source,scala]
----
val extTimeout = optionValue("timeout")
  .toInt
  .mapTo(t => t.seconds)
----

=== Fallback values

It is often not necessary that the user provides each and every parameter on
the command line; the application can assume meaningful default or fallback
values for missing parameters. There are basically two approaches to handle
such missing parameters in SCLI:

The first approach is to model optional parameters as such. For instance, the
data classes representing the parameters supported by the application can have
properties of type `Option` or potentially empty collections for parameters
that are not mandatory. Because the base types of SCLI for parameter values
already support optional parameters, there is no additional work to do for the
developer; when evaluating the values extracted, they come out as `Option` or
collection types. This approach forces the application logic to deal with
missing parameters. For instance, when accessing an optional property the
application could use a `getOrElse` construct to inject a fallback value if
necessary.

The second approach is to provide such fallback values directly during the
processing of the command line. For this purpose, SCLI offers functions to
assign fallback values to processors. The logic of these functions is that if
the extractor produces a value, this value is used; otherwise, the fallback
value comes into play. When using this approach the application logic can
assume that parameter values are present. A drawback could be that the module
responsible for command line processing needs the knowledge about meaningful
default values.

SCLI is not opinionated about the approach chosen by a concrete application.
It is also no problem to mix these approaches, so that an application can
decide on a per parameter basis which variant is the most suitable one. This
subsection describes the second approach.

==== Specifying a single fallback value

Every extractor based on the `SingleOptionValue` type supports setting a
single fallback value, which of course must correspond to the concrete data
type of the value. It is set via the `fallbackValue()` function. The sample
_transfer_ application uses this mechanism to set a fallback value for the
`chunkSize` option:

[source,scala]
----
final val DefaultChunkSize = 8192

val extChunkSize = optionValue("chunk-size")
  .toInt
  .fallbackValue(DefaultChunkSize)
  .mandatory
----

Note that it is now safe to use the `mandatory` modifier at the end: with the
fallback value in place, it is guaranteed that the option has a value. The
result type of the extractor is now `Try[Int]`.

==== Specifying multiple fallback values

For extractors operating on the `OptionValue` type, you can specify multiple
fallback values. The function for this purpose is consequently named
`fallbackValues()`. It expects a mandatory parameter for the first fallback
value and then a varargs parameter for an arbitrary number of further values.

The sample application does not use this function. So let's for a moment
consider that we want to set some default log entries to be applied if the user
has not provided the `log` option. Then the declaration of the extractor could
look as follows:

[source,scala]
----
val extLog = multiOptionValue("log")
  .fallbackValues("Transfer log", "Update without a concrete log message")
----

==== Specifying a fallback extractor

Setting concrete fallback values is just a special case for running another
extractor if an extractor does not yield a value. This replacement extractor
can then execute arbitrary logic to compute a value for the parameter in
question. This mechanism is supported for both single-valued and multi-valued
extractors in form of the `fallback()` function. We will present an example of
using this function when we discuss <<Password parameters>>.

=== Password parameters

There are use case when command line applications need a password to fulfill
their task. The _transfer_ application even supports two different password
parameters: one password to encrypt the data to transfer and another password
to authenticate against the target HTTP server.

Syntactically, passwords are just strings; so they could be treated as any
other option. For security reasons, however, it is not recommended passing a
password as plain text to a command line application. The password is then
visible when it is typed, and it can be stored in the history of the shell.

An alternative to expecting a password to be provided as parameter is letting
the application prompt the user for the password. SCLI supports this use case
with the `consoleReaderValue()` function. The function returns an extractor of
type `SingleOptionValue[String]` that yields the value the user entered on the
console. It expects the following parameters:

* the key of the option; this parameter is mandatory
* a flag whether the function should read a password. This flag controls
  whether the characters typed by the user are visible in the console, which
  should not be the case when entering passwords. The flag is *true* per
  default because reading passwords is the main use case for this function.
* an optional prompt to be displayed to the user; if undefined, the function
  prints the option key

Using this function, the extractor for the password for the HTTP server could
look as follows:

[source,scala]
----
val extHttpPwd: CliExtractor[SingleOptionValue[String]] =
  consoleReaderValue("password", optPrompt = "Enter the password for the HTTP server")
    .mandatory
----

This would work, but there is the drawback that the password now always has to
be entered manually. There may be cases, e.g. when the application is part of a
CI pipeline, when no user is present who could react on the prompt. Therefore,
a better solution would be to check whether a password is present on the
command line and only prompt the user if this is not the case.

This behavior can be achieved using a fallback extractor: the main extractor
for the password accesses the value from the option on the command line; only
if it is not present, the extractor reading from the console is invoked as
fallback. The parameter manager object from the _transfer_ sample application
defines a helper function which does exactly this:

[source,scala]
----
private def passwordExtractor(key: String, prompt: String): CliExtractor[Try[String]] =
  optionValue(key)
    .fallback(consoleReaderValue(key, optPrompt = Some(prompt)))
    .mandatory
----

Now the extractors for the password options can delegate to this helper
function:

[source,scala]
----
val extPwd = passwordExtractor("password", "HTTP server password")

val extCryptPass = passwordExtractor("crypt-password", "Encryption password")
----

=== Combining extractors

The extractors we have discussed so far have only been concerned with single
parameters. The link:README.adoc[README document] stated that SCLI supports
transforming of parameter values into data objects that can then be readily
consumed by applications. So how are those extractors for single parameters
composed to yield complex model objects?

The underlying mechanism consists of two parts: The first part is Scala's
built-in support for monads in form of *for* comprehensions. Because extractors
are monads, they can make use of the syntactic sugar Scala provides in this
area. So if `ext1`, `ext2`, and `ext3` are extractors of arbitrary result
types, we can write a construct as follows:

[source,scala]
----
val extCombined = for {
  v1 <- ext1
  v2 <- ext2
  v3 <- ext3
} yield // do some computation with v1, v2, v3
----

The values passed to the *yield* clause are the results produced by the
primitive extractors. They can now be combined in whatever way, e.g. stored in
the properties of a case class. The resulting _extCombined_ is an extractor
whose result type corresponds to the computation done on the single values.

This is only half of the way because the combination of the single result
values is still complex. The extractors generated based on the SCLI functions
typically return results of type `Try[X]`, where `X` is the data we are
actually interested in. So code to combine these results would have to check,
which results are successful and handle failures in a meaningful way. SCLI
offers support for this, and this is the second part of the combination
mechanism.

The support for combining extractor results is available as a set of overloaded
`createRepresentation()` functions defined in the `ParameterExtractor` module.
The functions work as follows:

* Each function expects a number of `Try` arguments, which can have different
  types.
* On a second parameter list, the functions expect a creation function. The
  signature of this function must correspond to the number and types of `Try`
  parameters, and it returns the result type of the resulting combined
  extractor.
* The functions now inspect all the passed in `Try` parameters:
** If all of them are successful, the creation function is invoked with the
   values stored in them. So the function can process the actual result values
   without having to deal with checks for `Success` or `Failure` values.
** In case there are failures, `createRepresentation()` does not invoke the
   creation function, but returns a `Failure` of the result type of the
   creation function that is initialized with a special exception class. It
   contains a collection of all the failures produced by the passed in
   extractors.

Let us see how the combination of extractors look in practice. A rather simple
example is the extractor for the configuration of the HTTP server. The data
type of this configuration contains only user credentials and is defined as
below:

[source,scala]
----
case class HttpServerConfig(user: String,
                            password: String)
----

We can now construct an extractor of this type based on the extractors for the
user name and the password:

[source,scala]
----
def httpServerConfigExtractor: CliExtractor[Try[HttpServerConfig]] = {
  val extUsr = optionValue("user")
    .mandatory
  val extPwd = passwordExtractor("password", "HTTP server password")
  for {
    user <- extUsr
    pwd <- extPwd
  } yield createRepresentation(user, pwd)(HttpServerConfig)
}
----

What happens here? First, the two extractors for the user name and the password
are defined using functionality we have discussed already. Then the code uses a
*for* comprehension to obtain the result values of these extractors. The
*yield* clause invokes the `createRepresentation` function and passes the
values from the extractors plus the function to create the result of the
combined extractor. In this special case, this function is just a reference to
the `apply` function of the `HttpServerConfig` companion object. We can use
this short syntax because we passed the values to `createRepresentation()` in
the same order as they are expected by the configuration case class. A more
explicit version of this construct would look as follows:

 yield createRepresentation(user, pwd)((u, p) => HttpServerConfig(u, p))

Now, as mentioned, the extractor for the HTTP server configuration is really a
simple case, as it just combines two values. However, it demonstrates the
principle pattern of combining extractors to more complex ones. This approach
works in exactly the same way with more extractors to be combined. It can
also be applied recursively; so in a next step, the extractor for the HTTP
server configuration could be combined with other ones to a more complex
configuration. Just list the extractors affected in a *for* and call
`createRepresentation()` passing in a suitable creation function.

NOTE: In order to support different numbers of parameters, there is a set of
overloaded `createRepresentation()` functions. Currently, functions accepting
up to 15 parameters exist. If your application has more parameters, you can
group them logically into different configuration objects; the sample
application uses the same approach. There is also a generic
`createRepresentationN()` function that can deal with an arbitrary number of
parameters. It does, however, not support a creation function with a specific
parameter list; instead, the creation function has to unpack the `Try`
parameters manually.

=== Running extractors

Throughout the previous sections, we have declared a number of extractors, from
simple ones to more advanced ones; but we have not yet seen the extractors in
action, i.e. how they are used to transforming the command line of an
application.

There are multiple ways to do this, and these ways reflect a bit the internal
structure of the SCLI library: There is the `ParameterManager` module serving
as a facade for a small number of services that collaborate during parameter
processing. When using the facade, you do not need to bother with details, and
a single function call is sufficient to parse the command line, run an
extractor on it, and return the result generated. This function will be fine
for most use cases, especially as it already allows a high degree of
customization. If you need full control over all the steps executed during
command line processing, you can also interact with the underlying services
directly.

This section focuses on the `ParameterManager` facade and its capabilities for
customization. Services that do the actual work are at least mentioned.

==== Running an extractor with standard settings

The single function offered by `ParameterManager` to apply an extractor to the
application's command line is `processCommandLine()`. At minimum, it expects
the command line (as a sequence of strings) and the extractor to execute. Its
result is a `Try` of a tuple with the extractor's result and a
`ProcessingContext`.

The extractor is supposed to return a `Try` of a specific type; depending on
the transformations it applies, there is always the chance that something goes
wrong. This is also the reason why `processCommandLine()` returns a `Try` -
failure results produced by the extractor need to be communicated to the
caller.

The second result of `processCommandLine()`, the processing context, is not that
obvious. It contains information that is useful, for instance, to display a
help message to the user. For now, we will ignore it. `ParameterManager` has a
type definition named `ProcessingResult` to represent this tuple.

So if we have an extractor yielding a result of type `Data` (for an imaginary
data class), and the sequence `args` contains the command line parameters of
the application, we can execute the executor in the following way:

[source,scala]
----
val triedResult = ParameterManager.processCommandLine(args, extractor)
triedResult match {
  case Success(tuple) =>
    val result = tuple._1
    // do something with result
  case r =>
    // the command line was invalid; handle the failure, e.g. show a help message
}
----

This fragment parses the command line with default settings. This means that
items on the command line prefixed with `--` are interpreted as options or
switches; items prefixed with `-` are considered short alias names for options.
If the command line contains a parameter that is unknown, result is a failure.

==== Running an extractor ignoring unknown options

Per default, the function for processing the command line checks whether there
are unknown elements; these are options or switches, for which no extractor
exists. When detecting such elements, the function produces a failure
referencing the unknown option key.

If you like more control over the handling of unexpected parameters, this
check can be disabled: simply pass the parameter _checkUnconsumedParameters_
with a value of *false* to the function:

 val triedResult = ParameterManager.processCommandLine(args, extractor,
   checkUnconsumedParameters = false)

Using the `ParameterContext` returned as part of the result, it is possible to
check for unexpected parameters. `ParameterContext` has a `Parameters` object,
and the `Parameters` class offers methods to query for parameter keys that have
not been accessed by any extractor.

==== Running an extractor with custom settings

_SCLI_ supports a number of ways to customize command line processing. For
instance, you can change the prefixes used to identify options or switches on
the command line, or you can modify the treatment of switches.

The entry point into customized command line processing is the
`processCommandLineSpec()` function of `ParameterManager`. This function
differs from the function used by the previous examples in that it does not
expect a `CliExtractor` as argument, but an `ExtractionSpec` object.
`ExtractionSpec` is a data class that holds the `CliExtractor` to execute; in
addition, it supports a couple of settings to configure the parsing and
extraction steps. When creating an instance of `ExtractionSpec` only the
`CliExtractor` is a mandatory parameter; for all other settings, the class sets
meaningful default values. By selectively setting specific properties, command
line processing can be tweaked to a certain degree. In the following, we give
some examples of possible adjustments.

One use case could be changing the prefixes for option and switch parameters.
For instance, on Windows the prefix `/` used to be quite popular, as in:

 copy /b test.txt target

In order to change the prefixes, you have to pass an object of the
`ParameterParser.OptionPrefixes` class to the _prefixes_ parameter of the
`ExtractionSpec` class. `OptionPrefixes` is a data class that holds an
arbitrary number of prefixes that are used by the parser to detect option or
switch parameters. Each prefix is represented by a `ParameterKey` object, so it
is clear whether it marks long or short parameter names.

To demonstrate this feature, we might want to support the Windows option prefix
in addition to the default one. This is achieved as follows:

[source,scala]
----
val extractor = ParameterExtractor.optionValue("flag")
  .alias("f")
  .mandatory
val prefixes = ParameterParser.OptionPrefixes(ParameterKey("/", shortAlias = false),
  ParameterKey("--", shortAlias = false), ParameterKey("-", shortAlias = true))
val spec = ExtractionSpec(extractor, prefixes = prefixes)

val triedResult = ParameterManager.processCommandLineSpec(args, spec)
----

Given this declaration, all the following command lines would be valid:

 my-app --flag value
 my-app /flag value
 my-app -f value

Another customization option supported by `ExtractionSpec` affects the handling
of switches: Some applications allow combining multiple single-letter switches
in a single parameter. A popular example is the _tar_ utility; it supports
command lines as the following:

 tar -zvxf data.tar.gz

The command line element `-zvfx` actually consists of four switches: `z` to
enable support for _gz_ files; `v` for verbose output; `f` to specify a source
file; and `x` to set the extract mode. Having these switches combined in a
single argument is a shorter form of specifying four switch arguments as in:

 tar -z -v -x -f data.tar.gz

Enabling this mode in _SCLI_ is just a matter of setting the
`supportCombinedSwitches` setting of `ExtractionSpec` to *true*. The _transfer_
sample application makes use of this feature; therefore, the following command
line will be accepted:

 transfer upload file.txt /shared/content/ --chunk-size 8182 -dHC

Here, in the last parameter, the following switches are set:

* the _dry-run_ mode is enabled
* hashes for uploaded files are generated
* files are removed after upload

Such parameters with multiple combined switches can appear everywhere on the
command line; there can be multiple of them, and it is possible to mix the
different styles to define switches. A current limitation is that for all the
switches that can be combined single-letter short alias keys are defined.

Applications that need to modify the way option and switch parameters are
recognized can make use of a further customization option: Per default, the
parameter parser checks whether a parameter on the command line starts with one
of the prefixes configured. If so, the prefix is removed, and the resulting
string becomes the key of the switch or option. Under the hood, these checks
and manipulations are done by a so-called _key extractor function_, which is
defined as follows:

[source,scala]
----
type KeyExtractorFunc = String => Option[ParameterKey]
----

So the function expects a string for the command line element as input and
returns an `Option` with a key if one could be extracted. `ExtractionSpec`
allows defining a custom key extractor function. This gives an application a
lot of control over the processing of option and switch parameters; it would be
possible to use a completely different algorithm to detect options and
switches. But even if you do not want to go that far, this mechanism gives an
application a hook to do some manipulations on parameter keys.

The _transfer_ sample application uses a custom key extractor function to
recognize long parameter keys independent of their case. So the parameter keys
`--chunk-size`, `--Chunk-Size`, and `--CHUNK-SIZE` should all mean the same. To
achieve this, it uses a custom extractor function that is based on the default
algorithm and checks whether a key could be extracted with the _shortAlias_
flag set to *false* (so short aliases remain case-sensitive). If this is the
case, the key is converted to lowercase. Here is the code that configures this
custom key extractor function in `TransferParameterManager`:

[source,scala]
----
val keyExtractor = ParameterManager.defaultKeyExtractor() andThen (opt =>
  opt.map(key => if (key.shortAlias) key else key.copy(key = key.key.toLowerCase(Locale.ROOT))))
val spec = ExtractionSpec(transferCommandConfigExtractor, keyExtractor = keyExtractor,
  supportCombinedSwitches = true)
----

The default key extractor function is available via the
`ParameterManager.defaultKeyExtractor()` function. It is then extended by the
conditional conversion of the resulting key to lowercase.

==== Advanced customizations

The customization options described so far have all been related to the
`ExtractionSpec` class. These options are interpreted by the `ParameterManager`
class, which then interacts with the `ParameterParser` module responsible for
the actual parameter parsing. Applications needing even more control over the
parsing of parameters could use functionality provided by `ParameterParser`
directly.

One feature provided by `ParameterParser`, which may be of interest for
applications, is the _classifier function_. When the parser processes a command
line it iterates over the single strings and invokes the classifier function on
each. The function then returns a result indicating whether this element is an
option, a switch, or an input parameter.

`ParameterManager` generates a default classifier function, but applications
could extend this function or replace it by a completely different
implementation.

It is even possible to replace the whole parameter parsing step. The functions
to process the command line discussed so far support an additional optional
parameter for the _parsing function_ to use. The parsing function is declared
as:

[source,scala]
----
type ParsingFunc = Seq[String] => ParametersMap
----

So, it basically converts a sequence of strings (representing the command line)
to a map of parameters, which can serve as input for the extraction step.
`ParameterManager` has functions to create a default parsing function based on
an `ExtractionSpec`, and with a custom classifier function, too. The parsing
function obtained that way can then be passed to `processCommandLineSpec()`. An
example making use of these features is available in the section about
<<Reading parameter files,parameter files>>.

==== Reading parameter files

If an application supports complex command line parameters and requires a
larger number of them to be present on each invocation, it is beneficial for
the users if sets of parameters could be stored in files and then simply be
referenced from the command line. For the _transfer_ sample application for
instance, it makes sense to have parameter files defining default upload or
download options.

_SCLI_ supports this use case; it can read parameters from files. A parameter
file is a plain text file where each line corresponds to an element of the
command line; empty lines are ignored. So a parameter file for the _transfer_
application defining default upload settings could look as follows:

 --time-out
 15
 --chunk-size
 16384
 --user
 uploader@transfer.org
 --upload-hashes

Provided that the file is available in the current directory under the name
`upload-settings.txt`, it can then be referenced from the command line using
the `--param-file` option or its short alias `-f` (of course, relative or
absolute paths to the parameter file are possible as well):

 transfer upload file1.txt file2.txt https://target.upload.com/data -f upload-settings.txt

The reading of parameter files is an optional step, which needs to be invoked
manually before the actual processing of the command line. `ParameterManager`
offers the function `processParameterFiles()` for this purpose. The function
basically takes the original command line - as a sequence of strings - and
replaces all references to parameter files by the content of the files. Result
is a modified sequence, which can then become the input for the parsing phase.
As the processing of parameter files can fail - users may provide wrong file
names, or there may be I/O errors -, the function actually returns a `Try` with
the modified sequence of arguments.

In addition to the original command line, `processParameterFiles()` needs an
`ExtractionSpec` and a _classifier function_ (refer to
<<Advanced customizations>>). This is because it needs to do a partial parsing
of the command line to detect the options referencing parameter files. The keys
of the options to look for need to be specified in the `fileOptions` property
of the `ExtractionSpec`, which accepts a sequence of `ParameterKey` objects.
The mandatory classifier function can be queried from `ParameterManager`. Here
the same function should be used as for the following command line processing;
therefore, the function should be obtained once and re-used in both steps. For
the processing step this is done by creating a custom _parsing function_ based
on the classifier function. How this looks like in practice can be seen in the
code fragment below, which shows the main function to process the command line
of the _transfer_ sample application:

[source,scala]
----
def processCommandLine(args: Seq[String]): Try[(TransferCommandConfig, ParameterContext)] = {
  val keyExtractor = ParameterManager.defaultKeyExtractor() andThen (opt =>
    opt.map(key => if (key.shortAlias) key else key.copy(key = key.key.toLowerCase(Locale.ROOT))))
  val spec = ExtractionSpec(transferCommandConfigExtractor, keyExtractor = keyExtractor,
    supportCombinedSwitches = true,
    fileOptions = List(ParameterKey("param-file", shortAlias = false), ParameterKey("f", shortAlias = true)))
  val classifierFunc = ParameterManager.classifierFunc(spec)
  val parseFunc = ParameterManager.parsingFuncForClassifier(spec)(classifierFunc)

  for {
    processedArgs <- ParameterManager.processParameterFiles(args, spec)(classifierFunc)
    result <- ParameterManager.processCommandLineSpec(processedArgs, spec, parser = parseFunc)
  } yield result
}
----

The function sets up an `ExtractionSpec` object, filling in the settings
already discussed under <<Running an extractor with custom settings>>. In
addition, it provides a list of two parameter keys to define the options
referencing parameter files - here the keys `--param-file`, and `-f` are
defined.

Based on this specification, the function can now obtain a classifier function
and a parsing function for this classifier function. The *for* comprehension at
the end of the function invokes `ParameterManager` with the settings prepared
so far. The first line triggers the processing of parameter files resulting in
a possibly extended sequence of arguments. This sequence goes as input into the
second line, which does the actual command line processing.

=== Conditional extractors

There are situations when extractors should only be executed under certain
circumstances. For instance, if one parameter on the command line has a
specific value, other parameters are enabled or disabled. A good real-life
example for such a constellation is an application supporting multiple
commands: each command may define its own set of parameters; only if the
specific command is active, the parameters related to it need to be gathered.

The _transfer_ sample application makes use of a couple of conditional
extractors. Based on those, the following sub sections explain this concept.

==== Constant extractors

In the section about <<Basic extractors>> we have missed out one extractor type
that is arguably even more basic than the ones discussed there: a constant
extractor. This was because the reasons behind this extractor type become only
obvious in the context of conditional extractor logic. Therefore, it is going
to be discussed now.

A constant extractor does not access the command line parameters, but directly
produces a constant result. The `constantExtractor()` function produces such
extractors. It expects the value to be returned by the constant extractor as
argument; the result type of the resulting extractor is then derived from this
value.

In the following sub sections we will see examples of using this function to
model conditional extraction logic. A constant extractor is especially useful
to define default values to use if certain conditions are not fulfilled.

==== Simple conditional logic

In the section <<Extracting an enum parameter>> we already encountered the
`CryptMode` enumeration class. The `--crypt-mode` option passes a value of this
class to the _transfer_ application. Encryption is active if this parameter
does not equal the value `CryptMode.None`. In this case, additional parameters
must be present on the command line to construct a `CryptConfig` data object,
especially the mandatory encryption password; otherwise, the application uses a
dummy `CryptConfig` instance with all settings disabled.

What is needed here is some basic if-then-else logic: if a specific condition
is *true*, execute one extractor; otherwise execute another extractor. SCLI
provides an extractor function to model such constructs: `conditionalValue()`.
The function expects three extractors as input:

* a condition extractor yielding a `Try[Boolean]`: it represents the condition
  to be evaluated. Based on the result of this extractor, the function decides
  which of the other extractors to execute.
* the if-extractor: an extractor to run if the condition extractor yields the
  value *true*. Its result type must be an arbitrary `Try`.
* the else-extractor: this extractor is run if the condition extractor yields
  the value *false*. It must have the same result type as the if-extractor.

So, actually this is a rather simple concept. The extractors for the if and
else logic are typically nothing special; they access the command line in the
usual way to generate a result. The condition extractor will probably access the
command line, too, but it will execute some logic to compute a boolean result
value. Because this logic may produce an error, the result type of this
extractor is `Try[Boolean]`; if the result is a failure, this becomes the
result of the whole conditional extractor.

To make this concrete, here is how the sample application uses the
`conditionalValue()` function to extract a `CryptConfig` object. First, this is
the declaration of `CryptConfig`:

[source,scala]
----
case class CryptConfig(cryptMode: CryptMode.Value,
                       password: String,
                       algorithm: String)
----

The application defines two functions to define extractors for a `CryptConfig`.
One function declares the actual extractor that fetches the parameter values
from the command line unconditionally:

[source,scala]
----
private def definedCryptConfigExtractor: CliExtractor[Try[CryptConfig]] = {
  val extCryptPass = passwordExtractor("crypt-password", "Encryption password")
  val extCryptAlg = optionValue("crypt-alg")
    .fallbackValue(DefaultCryptAlgorithm)
    .mandatory
  for {
    mode <- cryptModeExtractor
    pwd <- extCryptPass
    alg <- extCryptAlg
  } yield createRepresentation(mode, pwd, alg)(CryptConfig)
}
----

This extractor uses the mechanisms described under <<Combining extractors>> to
produce a result object from multiple parameter values. The other function uses
`conditionalValue()` to execute this extractor only if encryption is actually
enabled; otherwise, it applies a <<Constant extractors,constant extractor>> to
generate a default `CryptConfig` object:

[source,scala]
----
def cryptConfigExtractor: CliExtractor[Try[CryptConfig]] = {
  val extCryptEnabled = cryptModeExtractor
    .map(triedMode => triedMode.map(_ != CryptMode.None))
  conditionalValue(extCryptEnabled, ifExt = definedCryptConfigExtractor,
    elseExt = constantExtractor(Success(DisabledCryptConfig)))
}
----

The most interesting part here is the `extCryptEnabled` extractor, which is
passed as condition extractor to `conditionalValue()`. Note how it is derived
from the standard extractor for the `CryptMode` by mapping a predicate function
to the original result. This predicate checks whether the `CryptMode` is not
`CryptMode.None`.

With this conditional extractor in place, invoking the 'conditionalValue()'
function with the parameters required is straight-forward.

==== Commands

Command line applications often make use of commands that select specific
functionality to execute. A very prominent example is `git` which supports
numerous commands like _clone_, _add_, _commit_, _push_, and many more. One
characteristic of this approach is that the set of command line parameters
accepted by the application can change partly or even completely depending on
the command provided by the user. So this is again a special case of executing
extraction logic conditionally.

Theoretically, the `conditionalValue()` function introduced in the previous
section would be able to implement the logic of dealing with commands. However,
the result would be rather complex and hard to read: the processing of multiple
commands requires nesting conditional extractors, where each extractor checks
for a specific command, executes the corresponding command-specific extractors
in the if-extractor, and delegates to the next conditional extractor for
checking for another command. SCLI offers an easier solution in form of the
`conditionalGroupValue()` function.

The background of this function is that it supports multiple groups of command
line parameters. Each group has a name and is represented by an extractor
(which can of course be a complex one combining multiple other extractors). All
of these extractors must have the same result type, which becomes the result
type of the extractor returned by `conditionalGroupValue()`. The function
expects the following arguments:

* an extractor of type `Try[String]` which selects the name of the active group
* a map of type String -> extractor associating the group names with their
  extractors

The resulting extractor first invokes the extractor passed as first argument to
the function to obtain the name of the active group. It then invokes the
extractor stored in the map under this name. If the group name extractor yields
a failure or a name which is not contained in the map, result is a
corresponding failure.

So basically, while the `conditionalValue()` function selects one of two
extractors based on a boolean condition, `conditionalGroupValue()` selects one
extractor from an arbitrary number of extractors based by its name.

For the implementation of commands this logic fits nicely. The name of the
command can be used directly as key to the map. One requirement of the function
is that all the extractors in the map must return the same result type; but the
commands will typically accept different sets of parameters. The solution is
using a common base trait for the configuration of commands which is extended
by command-specific data classes.

We show the usage of this mechanism for the _transfer_ application. For reasons
of simplicity, this application supports only two commands for uploading or
downloading files. The following fragment shows how the parameters supported by
these commands are modelled:

[source,scala]
----
  sealed trait CommandConfig

  case class UploadCommandConfig(uploadHashes: Boolean,
                                 removeUploadedFiles: Boolean) extends CommandConfig

  case class DownloadCommandConfig(targetFolder: Path,
                                   overrideLocalFiles: Boolean) extends CommandConfig
----

Note the usage of Scala's concept of sealed classes. This makes sure that there
is only a controlled number of sub classes and allows the compiler to check for
exhaustive *match* expressions. The `TransferParameterManager` module defines
extractors for `UploadCommandConfig` and `DownloadCommandConfig` as usual. Then
it has the following function to construct the extractor for the command
configuration:

[source,scala]
----
final val CommandUpload = "upload"

final val CommandDownload = "download"

private def commandConfigExtractor: CliExtractor[Try[CommandConfig]] = {
  val extCmdName = inputValue(index = 0, optKey = Some("transfer-command"))
    .toLower
    .mandatory
  val groupExtractors = Map(CommandUpload -> uploadCommandConfigExtractor,
    CommandDownload -> downloadCommandConfigExtractor)
  conditionalGroupValue(extCmdName, groupExtractors)
}
----

Based on the preceding explanations, this function should be understandable.
The name of the command to execute is obtained from the first input parameter.
We want to be tolerant regarding case, therefore, we apply a `toLower`
transformation. The function constructs a map with the specific sub extractors
keyed by the command name and invokes `conditionalGroupValue()`.

After the successful extraction of a concrete command configuration, the
application can handle the command entered by the user in a way similar to the
following construct:

[source,scala]
----
commandConfig match {
  case uc: UploadCommandConfig =>
    handleUpload(uc)
  case dc: DownloadCommandConfig =>
    handleDownload(dc)
}
----

==== Complex group selection logic

While commands are an obvious use case of the `conditionalGroupValue()`
function, it is usable in other contexts as well. The _transfer_ sample
application has another example in the processing of the URL of the target
server.

_transfer_ supports different types of target servers, namely file and HTTP
servers. Each server type of course needs specific parameters for its
configuration. To handle these parameters, `TransferParameterManager` uses an
approach similar to the processing of commands: It defines again a sealed base
trait for server configurations and concrete sub classes for the server types
supported:

[source,scala]
----
sealed trait ServerConfig

case class FileServerConfig(rootPath: Option[String],
                            umask: Int) extends ServerConfig

case class HttpServerConfig(user: String,
                            password: String) extends ServerConfig
----

The extractor for the server configuration calls `conditionalGroupValue()`
passing in a map with the extractors for these configuration types. The
extractor to select the correct one from the map is, however, slightly more
complex. It accesses the server URL and checks whether it starts with a prefix
indicating an HTTP server. If this is the case, it returns a name selecting the
HTTP server extractor; otherwise, the file server extractor is selected. The
code is as follows:

[source,scala]
----
private val ServerTypeFile = "file"

private val ServerTypeHttp = "http"

private def serverConfigExtractor: CliExtractor[Try[ServerConfig]] = {
  val groupExtractors = Map(ServerTypeFile -> fileServerConfigExtractor,
    ServerTypeHttp -> httpServerConfigExtractor)
  conditionalGroupValue(serverTypeExtractor, groupExtractors)
}

private def serverTypeExtractor: CliExtractor[Try[String]] =
  serverUriExtractor.mapTo { uri =>
    if (uri.startsWith("http://") || uri.startsWith("https://")) ServerTypeHttp else ServerTypeFile
  }.mandatory

private def serverUriExtractor: CliExtractor[SingleOptionValue[String]] =
  inputValue(optKey = Some("serverUri"), index = -1)
----

Note that by extending the selection logic, it is pretty easy to add support
for configuration options for other types of servers.

=== Generating help

This section describes the functionality provided by SCLI related to the
generation of help information.

==== Deciding when to display help

Displaying help information is a typical use case of command line applications.
If the set of supported parameters is not trivial, it is hard for users to
remember the exact syntax, and therefore, there should be ways to get an
explanation about the applications' abilities, or a notification if invalid
parameters were specified.

Command line applications usually display help information if at least one of
the following conditions hold:

* Invalid or missing mandatory parameters have been detected.
* The user has explicitly requested help, e.g. by passing in a specific switch
  on the command line, such as `--help`.

The section about <<Running extractors>> showed the result returned by
`ParameterManager` for the processing of the command line: a `Try` of a tuple
with the actual extraction result and a `ProcessingContext` object. Based on
this information, the application now needs to decide whether it can consume
the result and do its actual job or whether it should show a help screen and
exit. As the data types involved make this decision not trivial - one has to
inspect the `Try` and check certain attributes of the context object -, there
is a helper function to simplify this task: `ParameterManager.evaluate()`.

The function accepts the result of the command line processing and converts it
to an `Either`, which is either a `Right` with the extraction result or a
`Left` with the `ProcessingContext`. In case of the `Right`, the application
can be sure that its parameters have been parsed successfully; so it can go
ahead making use of them. Otherwise, it should use the processing context to
generate help information and stop processing afterwards.

The demo _transfer_ application contains a main class - `TransferApp` - to
demonstrate the decision logic necessary. It mainly delegates to
`TransferParameterManager` to trigger command line processing and evaluation,
but then checks whether a transfer can be done or help needs to be displayed:

[source,scala]
----
object TransferApp {
  def main(args: Array[String]): Unit = {
    TransferParameterManager.evaluateCommandLine(args.toIndexedSeq) match {
      case Right(config) => transfer(config)
      case Left(context) =>
        println(TransferParameterManager.generateHelp(context))
    }
  }

  private def transfer(config: TransferCommandConfig): Unit = {
    // actual transfer logic
  }
}
----

The `evaluateCommandLine()` function of `TransferParameterManager` is
implemented as follows:

[source,scala]
----
def evaluateCommandLine(args: Seq[String]): Either[ProcessingContext, TransferCommandConfig] =
  ParameterManager.evaluate(processCommandLine(args))
----

It calls its own function to process the command line (which we have presented
in the section <<Reading parameter files>>), and then delegates to the
parameter manager in order to evaluate the result. `TransferApp` now matches
over the resulting `Either` to determine the actions to take. In case of a
`Left` it delegates again to `TransferParameterManager` to generate help
information. In the remaining parts of this section, we will discuss in detail
how this generation of help screens works.

==== Generating a basic help screen

Before digging into the details of help screen generation, some basic
understanding of the concepts used by SCLI in this area is helpful. We have
already seen that help generation is based on a `ProcessingContext` object
obtained by evaluating a command line processing result. Such a processing
context contains a `ParameterContext` object and a flag whether the user has
explicitly requested help. The flag is useful to distinguish between the
reasons why to display help; it could also affect the output generated by the
application. For instance, if the flag is *false*, the application knows that
errors were detected during command line processing, and it should probably
present those to the user.

The `ParameterContext` stores information that has been generated during
command line processing. This includes a map of parameters as the result of the
first parsing phase and a `ModelContext` object. The latter has information
about all the parameters supported by the application with additional metadata
attributes; the attributes stem from the declaration of extractor objects using
the domain-specific language offered by SCLI.

The principle idea behind the generation of help screens is to iterate over the
parameters stored in the `ModelContext`, maybe filter them based on certain
criteria, sort them, and display some of their metadata attributes in a
suitable form. SCLI has special support for the generation of tabular data. It
offers functions that do the iteration (which is customizable by passing in
filter and sort functions) and can invoke so-called _column generator
functions_ for each parameter. This yields a table with rows representing the
parameters selected and columns corresponding to the column generator functions
provided. SCLI can layout such tables, so that they can be directly printed to
the console. It offers a set of pre-defined column generator functions, but
applications can easily define their own ones to address special needs.

In order to generate meaningful help screens, sufficient metadata must be
available for the application's parameters. Some attributes are generated
automatically when declaring extractors, for instance the parameter key,
possible aliases, its type (option, switch, etc.), its multiplicity, or default
values to apply. In the context of help screens, the most relevant attribute is
probably a help text. This is a text created by the application developer that
describes a specific parameter. The examples in this tutorial have skipped help
texts so far, but all the functions that allow the declaration of a parameter
support them. So the first step in generating help screens is the definition of
help texts for all the parameters available and assign them when declaring the
corresponding extractors.

Let's see how this is done in the demo application: The
`TransferParameterManager` class defines constants for the help texts of the
parameters it supports. The fragment below shows an excerpt from these
declarations:

[source,scala]
----
private val HelpTransferCommand =
  """The command defining the transfer operation to be executed. Depending on the command, additional \
    |command-specific parameters are enabled or disabled. The following commands are supported \
    |(case does not matter):
    |- upload: uploads files to the server
    |- download: downloads files from the server""".stripMargin

private val HelpTransferFiles =
  """A list of files to be uploaded to or downloaded from the target server."""

private val HelpTransferServer =
  """The URI of the server which is the target of the transfer operation. Different types of servers \
    |are supported; depending on the server type, further parameters are enabled or disabled. \
    |The server type is determined by the scheme of the URI provided: the schemes 'http' \
    |or 'https' select an HTTP server; for all other schemes a file server is used.""".stripMargin

private val HelpChunkSize =
  """Defines the chunk size for transfer operations (in kilobytes). Using this option, the data transfer \
    |can be tweaked towards smaller or larger files.""".stripMargin
----

Here Scala's multi-line strings are used to define help texts. Per default,
line breaks in these declarations become part of the strings and would
therefore appear in the output as well. This is sometimes desired, for instance
in the help text of the transfer command where the description of each command
should start on a new line. In contrast, line breaks made just to format the
source code should have no effect to the output. This is achieved by using a
backslash as line continuation character.

With the constants for help texts in place, they can be referenced when
declaring extractors. Extractors support an `Option` argument with a help text
that is set to `None` per default. `TransferParameterManager` now passes an
explicit help text value in. Here is again a fragment showing how this is done;
note the `Some(HelpText)` parameters in the definitions of options, switches,
or input parameters:

[source,scala]
----
val extSrcFiles = inputValues(fromIdx = 1, toIdx = -2, optKey = Some("transferFiles"),
  optHelp = Some(HelpTransferFiles))
  .multiplicity(atLeast = 1)
  .toPath
  .map(_.map(_.toList))
val extChunkSize = optionValue("chunk-size", Some(HelpChunkSize))
  .toInt
  .fallbackValue(DefaultChunkSize)
  .mandatory
  .alias("s")
val extDryRun = switchValue("dry-run", Some(HelpDryRun))
  .alias("d")
----

Now everything is reade for actually generating a help screen. To do this, we
make use of functionality in the `HelpGenerator` module; it contains a bunch of
functions that support producing tabular output with help information. The
column generator functions mentioned in the introductory paragraphs are located
here as well. We will start with a bare minimum and refine the result in the
following sections.

To present the user a minimum of help information, we should display all the
parameters supported by the application together with their help texts. The
`TransferParameterManager.generateHelp()` function taken from the demo
application shows how this can be done:

[source,scala]
----
def generateHelp(context: ProcessingContext): String = {
  import HelpGenerator._
  val modelContext = context.parameterContext.modelContext
  val keyGenerator = parameterNameColumnGenerator()
  val helpGenerator = attributeColumnGenerator(AttrHelpText)

  generateParametersHelp(modelContext)(keyGenerator, helpGenerator)
}
----

The function imports `HelpGenerator._` to have direct access to all the
functions and constants defined in this module. It then declares two column
generator functions: one to display the parameter names and one to show the
help texts assigned to parameters. Both are standard column generator functions
provided by `HelpGenerator`. The latter is pretty generic and can output an
arbitrary attribute from the metadata of a parameter; the help text is stored
as such an attribute.

NOTE: The `attributeColumnGenerator()` function is not limited to the help
text, but can be used to display other attributes from the metadata of
parameters as well. The `ParameterModel` module defines constants for all the
attributes that are available; these constants start with the prefix `Attr`.

The actual help text is now produced by the
`HelpGenerator.generateParametersHelp()` function passing in the model context
(obtained from the `ProcessingContext`) and the list of column generators.

==== Soft-wrapping help texts

When we start the _transfer_ demo application in its current form and enter
invalid parameters it prints out a help text, but the output does not really
look nice; the help texts are often too long and flow into the next line, and
line continue characters are not evaluated. This is because the column
generator we use to display the help texts of parameters,
`attributeColumnGenerator()`, is very generic and just outputs the value of the
attribute selected verbatim. To improve the output, we can wrap the function
into another function that can deal with long, multi-lined texts:
`wrapColumnGenerator()`. The function expects the generator function to wrap
and a maximum text length. It obtains the text from the wrapped generator and
inserts line breaks automatically (where whitespace is detected), to enforce
the maximum line length. It handles the line continuation characters as well.
When we change the declaration of the column generator function to the help
text column as follows:

[source,scala]
----
val helpGenerator = wrapColumnGenerator(attributeColumnGenerator(AttrHelpText), 70)
----

the output becomes much more readable, as shown in the fragment below:

[source]
----
 --chunk-size             Defines the chunk size for transfer operations (in kilobytes). Using
                          this option, the data transfer can be tweaked towards smaller or
                          larger files.

 --crypt-alg              Defines the algorithm to be used for encryption. This parameter is
                          evaluated only if encryption is enabled.

 --crypt-mode             Determines what kind of encryption is used during the transfer
                          process. This parameter can have the following values (case does not
                          matter):
                          - None: encryption is disabled
                          - Files: the content of files is encrypted
                          - FilesAndNames: the content of files and their names are encrypted
----

As column generators are just functions, they can be composed to produce more
complex results. Many of the generator functions offered by `HelpGenerator`
follow this principle.

==== Showing input parameters first

In the help information generated so far, input parameters appear as any other
parameters in the list, sorted by their keys. For users, this may be a bit
confusing, as these parameters are somewhat special and have to be present in
any case. So it makes sense to have two tables with parameters: one for the
input parameters and one for options and switches.

While the `generateParametersHelp()` function we used so far generates tabular
help data and renders it immediately, we now do the rendering separately. This
has the advantage that the tables for the input parameters and the other
parameters can be aligned, so that they have equal column widths. The code how
to produce the enhanced output is shown next:

[source,scala]
----
  def generateHelp(context: ProcessingContext): String = {
    import HelpGenerator._
    val modelContext = context.parameterContext.modelContext
    val keyGenerator = parameterNameColumnGenerator()
    val helpGenerator = wrapColumnGenerator(attributeColumnGenerator(AttrHelpText), 70)

    val tableParams = generateHelpTable(modelContext, filterFunc = InputParamsFilterFunc,
      sortFunc = inputParamSortFunc(modelContext))(keyGenerator, helpGenerator)
    val tableOptions = generateHelpTable(modelContext,
      filterFunc = negate(InputParamsFilterFunc))(keyGenerator, helpGenerator)
    val helpTexts = renderHelpTables(List(tableParams, tableOptions))
    val buf = new StringBuilder(1024)
    buf.append(helpTexts.head)
      .append(helpTexts(1))
    buf.toString()
  }
----

A table with help information is generated using the `generateHelpTable()`
function. The function requires the model context, and supports some further
arguments to customize the content of the resulting table. Here we provide a
filter function and a sort function. The filter function is necessary to
restrict the data in the tables: the first table should contain only input
parameters, the second one all but input parameters. The `HelpGenerator` module
provides pre-defined filter functions for this purpose. `InputParamsFilterFunc`
is a constant that filters for input parameters only. The module also supports
logical operators on filter functions. For the generation of the second table,
we use the `negate()` function that produces the inverse of a filter; so the
filter function `negate(InputParamsFilterFunc)` selects all the parameters,
which are not of type input parameter.

`generateHelpTable()` further supports a function to sort the rows of the
table. The default sort function sorts rows alphabetically on the parameter
keys. This is fine for the second table for options and switches; for input
parameters, this order is not ideal though: for them, the order in which they
appear on the command line is crucial. The `inputParamsSortFunc()` function
from the `HelpGenerator` module returns a sort function that adheres to this
order.

Both tables have the same structure, therefore, we use the same column
generator functions. The `renderHelpTables()` function finally creates a string
representation for the passed in tables. Each table is converted to its own
string, so the strings could be printed separately (e.g. with different
headings or explanatory texts). However, the function ensures that the columns
of the tables have been padded to the same lengths.

==== Generating a short overview of input parameters

Many command line applications show a short synopsis of their intended usage
that lists at least all their input parameters. The parameters are decorated
with special symbols to indicate whether they are optional or whether they can
be repeated. SCLI supports the generation of such an overview; so the
_transfer_ demo application makes use of this feature.

`HelpGenerator` offers the function `generateInputParamsOverview()`. It expects
the model context and returns a list containing the keys of all input
parameters with special decorations. The caller is then free how to display
this information. As the _transfer_ application wants to produce a single-line
overview, it invokes `mkString()` on this list. Here is the updated code to
generate the help screen:

[source,scala]
----
  val buf = new StringBuilder(1024)
  buf.append("Usage: transfer [options] ")
    .append(generateInputParamsOverview(modelContext).mkString(" "))
    .append(CR)
    .append(CR)
    .append(helpTexts.head)
    .append(helpTexts(1))
  buf.toString()
----

So the help screen starts with a line showing the intended usage of the
application. Then - after two empty lines - the tables for the input parameters
and the options and switches follow. `CR` is a constant provided by
`HelpGenerator`, which has been initialized to the new-line character of the
current platform; this is an easy means to add new-lines to the generated help
output. The _Usage_ line looks as follows:

 Usage: transfer [options] <transferCommand> <transferFiles1> [<transferFiles2> ...] <serverUri>

The auto-generated part contains entries for all the input parameters
supported. Single-valued, mandatory parameters appear with their key in angular
brackets. Optional parameters are decorated with square brackets. If a
parameter can have multiple values, the output shows multiple keys with
indices; optional values have again square brackets. An ellipsis indicates that
further values are possible.

If you do not like the symbols to mark parameters or indicate their
multiplicity, you can change them by creating an instance of the
`InputParamOverviewSymbols` case class and pass it to the
`generateInputParamsOverview()` function.

==== Showing parameter aliases

If an application defines aliases for its parameters, these alternative keys
should of course be visible in help screens. With the current implementation of
`TransferParameterManager.generateHelp()`, this is not the case for the
_transfer_ demo application.

The reason for this short-coming is that the function uses the column generator
`parameterNameColumnGenerator()` to display the parameter keys in the help
tables it generates. This generator function is pretty basic, and - as its name
indicates - just outputs the key of a parameter. Fortunately, `HelpGenerator`
offers a more powerful function for our purpose:
`parameterKeyWithAliasesColumnGenerator()`. This function displays the key and
all the aliases defined for a parameter separated by a configurable delimiter
character. It is also possible to specify a maximum width for the output to
wrap the line if long keys are used. As a further configuration option, the
function supports customizing the parameter prefixes in its output. Per default
it uses the prefix `--` for long parameter keys and `-` for short keys. If an
application has different conventions, it should adapt these settings.

`TransferParameterManager` only uses the option to limit the width of the
output generated, so the declaration of the column generator function for the
parameter keys becomes:

[source,scala]
----
val keyGenerator = parameterKeyWithAliasesColumnGenerator(maxLength = 18)
----

==== Showing parameter default values

For optional parameters, it is often helpful to show the user the default value
the application assumes if the user has not specified this parameter. When
declaring extractors, default values are automatically recorded as an attribute
of the parameter; so they are available to column generators when producing
help screens.

The _transfer_ demo application wants to show this information in its help
output; it can be obtained using an `attributeColumnGenerator()` function for
the `AttrFallback` attribute. The easiest option would be adding this function
as a new column to the help tables produced by the application. This is
perfectly fine, but to demonstrate some other functionality, the default values
should be integrated with the help text of the parameters. (One advantage of
this approach is that it helps to prevent the table from becoming too wide.)
So if a default value exists for a parameter, it should be displayed in a new
line after the help text, prefixed with the string _Default value:_.

`HelpGenerator` offers some functions that can combine the output of other
column generator functions. That way the content of a cell in the help table
can be produced by multiple generators, and thus can contain different pieces
of information. One of these functions is `composeColumnGenerator()`, which
just concatenates the lines produced by the generators passed as arguments to
the function. Another function of this type is `prefixColumnGenerator()`. It
wraps another column generator and adds a configurable prefix to its result,
but only if a result is produced at all.

We can solve the requirement with the default value by combining these two
functions: With `prefixColumnGenerator()`, we add the prefix _Default value:_
to the actual default value; with `composeColumnGenerator()`, the resulting
string for the default value is appended to the help text. If no default value
is present, these functions do not generate any additional output. Below is the
improved declaration of the generator for the help column integrating the
functions described:

[source,scala]
----
val helpGenerator = composeColumnGenerator(
  wrapColumnGenerator(attributeColumnGenerator(AttrHelpText), 70),
  prefixColumnGenerator(attributeColumnGenerator(AttrFallbackValue),
  prefixText = Some("Default value: ")))
----

SCLI records default values for all parameters that have a `fallbackValue()`
modifier in their declaration, and also for switches (where the default value
is equivalent to the absence of the switch). Per default, it stores the string
representation of the default value, which is a good choice in most cases. If
you need an alternative or more explicit description of a default value, use
the `fallbackValueWithDesc()` modifier instead of `fallbackValue()`. It accepts
an additional `Option` argument with the description of the default value. (The
argument is an `Option` because by setting it to `None` the recording of the
default value can be suppressed.)

The _transfer_ demo application sets a default value for the _umask_ to apply
when transferring data to a file server. However, instead of the octal value,
a more meaningful description should be presented to the user. Therefore, the
declaration of the corresponding extractor looks as follows:

[source,scala]
----
val extUmask = optionValue("umask", Some(HelpFileServerUmask))
  .toInt
  .fallbackValueWithDesc(Some("read-only"), DefaultUmask)
  .mandatory
----

The fragment below shows an excerpt of the help screen generated based on the
improvements described in this subsection:

[source]
----
--chunk-size, -s    Defines the chunk size for transfer operations (in kilobytes). Using
                    this option, the data transfer can be tweaked towards smaller or
                    larger files.
                    Default value: 8192

--crypt-alg         Defines the algorithm to be used for encryption. This parameter is
                    evaluated only if encryption is enabled.
                    Default value: RSA

--umask             Defines the Unix umask for new files stored on the file server.
                    Default value: read-only

--upload-hashes,    Determines whether hashes should be uploaded together with files.
-H                  Default value: false
----