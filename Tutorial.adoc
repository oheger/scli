= SCLI Tutorial

This document describes the features of the SCLI library in form of usage
examples, starting from easy ones and advancing to more complex scenarios.
Most of the examples do not build upon each other; so you might directly
proceed to the section you are interested in the most.

NOTE: While not strictly necessary, it is helpful to understand the underlying
concepts used by SCLI before browsing the usage examples in this document. They
are described in the link:README.adoc[README document].

== Introduction

This document describes the usage of the SCLI library based on an imaginary
command line interface application called _transfer_. _transfer_ can download
or upload a number of files from or to a server. It supports a number of
options to configure the data transfer; for instance, it is possible to encrypt
data, to set timeouts, or to enable a _dry-run_ mode. For the server, which is
the target of the transfer operation, the application supports multiple
transfer protocols; depending on the protocol selected, different additional
parameters are expected. So if the target server uses the HTTP protocol, the
user needs to provide credentials for _basic auth_ authentication.

The general command line for our hypothetical _transfer_ application looks as
follows:

`transfer [options] <command> <file1> [<file2>..<fileN>] <serverUri>`

_<command>_ can be either `upload` or `download` and determines the direction
of the data transfer. After the command, an arbitrary number of file paths to
be transferred are listed; but there must be at least one file. The last
argument is the URI of the server, which is the target of the transfer. The
_spec_ of this URI is evaluated to determine the server type. The server type
influences the set of parameters accepted by the application; options
configuring an HTTP server are only accepted if the server type is actually
HTTP.

== Sample code

Most of the code examples used throughout this document are taken from the
link:./src/test/scala/com/github/scli/sample/transfer/TransferParameterManager.scala[TransferParameterManager]
module. It defines the data structures to represent the arguments accepted by
the _transfer_ application and declares extractors to actually process the
arguments. For your own applications, you can follow a similar pattern to keep
the logic of command line processing in a dedicated parameter manager class.

When you inspect the _TransferParameterManager_ source code, you will see a
number of case classes ending on the suffix _Config_ that are representations
of the command line arguments accepted by the sample application. The top-level
case class is _TransferCommandConfig_; a successful processing of the command
line yields an instance of this class. With such an object available, the
application has direct and type-safe access to the arguments provided by the
user. The examples in this document show how the single arguments are read from
the command line, processed, and eventually stored in those config objects.

There is also a test class for the _TransferParameterManager_ module, using the
_transfer_ sample application to test the library against a realistic use case:
link:./src/test/scala/com/github/scli/sample/transfer/TransferParameterManagerSpec.scala[TransferParameterManagerSpec].
Use this class as a source for ideas how to test your own command line
processing logic based on the SCLI library.

== Usage examples

This section contains many code examples showing SCLI in action to process the
command line of the _transfer_ sample application.

=== Basic extractors

In order to read the values of arguments from the command line and convert them
to a suitable representation, the developer has to define extractors. This
subsection demonstrates the domain specific language offered by SCLI for the
definition of basic extractors.

The functions used within this section are defined by the _ParameterExtractor_
module. So they require this import:

`import com.github.scli.ParameterExtractor._`

NOTE: The DSL provided by SCLI is implemented using Scala _implicit functions_,
which are also defined by the `ParameterExtractor` class; the wildcard import
above makes sure that these functions are available in the current scope.

==== Extracting a single string option value

One entry point into extracting the values of options is the _optionValue()_
function. It returns a _CliExtractor_ of type _SingleOptionValue[String]_. This
can be the basis for further data type conversions. The function expects the
key of the option as argument. It assumes that the option can have at most
one value (which is reflected by the result type). This should be the most
typical use case.

One example of such an option in the sample application is the `tag` option.
It allows the user to specify a label to be assigned to the transfer operation.
The assignment only happens if the option is present:

 transfer --tag "v1.1.2" upload ./source /target

This use case is actually handled by the most basic extractor:

[source,scala]
----
val extTag = optionValue("tag")
----

This extractor yields an `Option[String]`, which corresponds to the basic
`SingleOptionValue[String]` type; it fails if the option occurs multiple times
and thus has more than one value.

NOTE: Actually, `SingleOptionValue[String]` corresponds to a
`Try[Option[String]]`. Extractors typically return `Try` types because
transformations on the user input can always fail. When combining the results
of extractors failed extractions are detected and collected into a meaningful
error message.

==== Extracting an option with multiple string values

The _transfer_ sample application supports the command line option `log` to
define lines for the transfer log. The option can occur multiple times to
generate multiple log entries, as in the following fragment:

 transfer --log "Updating sources" --log "Version 1.1.2-2020-06-28" \
    --log "by test.user@scli.org" upload ./source /target

The type of the `log` option is `Iterable[String]`, which corresponds to the
basic `OptionValue[String]` type. For the creation of extractors of this type,
the _multiOptionValue()_ function is responsible. Its signature is analogous to
the one of the _optionValue()_ function:

[source,scala]
----
val extLog = multiOptionValue("log")
----

Except for the different result type, extractors created by the functions
_optionValue()_ and _multiOptionValue()_ are very similar in the features they
support; a common set of transformations is available for both. We will discuss
such transformations later in this tutorial.

==== Extracting an option with a mandatory string value

Some parameters must always be present for the application to fulfill its
function. In the _transfer_ application, if the target is an HTTP server, the
user must provide the credentials for basic auth - a user name, and a password.

To indicate that an extractor yields a single, mandatory value, it needs to be
decorated with the `mandatory` modifier. This is actually a difference between
extractors for single option values (constructed via `optionValue()`) and those
for multi option values (created by `multiOptionValue()`): `mandatory` only
works for single values. The modifier changes the result type of the extractor
from `Try[Option[String]]` to `Try[String]`. The extractor produces a failure
if no value is present for this argument. The following snippet shows the
declaration of the extractor for the user name for the HTTP server:

[source,scala]
----
val extUsr = optionValue("user")
  .mandatory
----

=== Input parameters

Input values are elements on the command line that cannot be assigned to
options. The _transfer_ sample application uses the following parameters of
this type (in this order) - refer to the <<Introduction>> section for further
details:

* A command that determines the direction of the transfer
* A sequence of paths to be transferred
* The URI of the target server

This set of input parameters demonstrates a number of use cases:

* Input parameters typically get their meaning from their position on the
  command line. The application specifies that the first parameter is the
  transfer command, while the last is the server URI. Note that other options
  can appear between input parameter values; they are ignored when extracting
  the values of a specific input parameter.
* Like options, input parameters can have either a single or multiple values.
  Input parameters with multiple values make the positioning more complicate:
  If the exact number of values for a parameter is not known (as is the case in
  the sample application for the number of paths to transfer), specifying
  absolute parameter indices is no longer possible.
* Despite from their special syntax, the values of input parameters should be
  accessible in the same way as option values; for instance, transformations
  on values should be possible.

We will demonstrate how SCLI addresses these use cases.

==== Extracting an input parameter with a single value at a specific position

For the creation of extractors for input parameters, the SCLI library offers a
pair of functions analogously to `optionValue()`, and `multiOptionValue()`:
`inputValue()` produces an extractor for an input parameter with a single
value; extractors generated by `inputValues()` in contrast support multiple
values.

In the _transfer_ sample application, the easiest input parameter is the first
one, the transfer command. Its position on the command line is known exactly.
The `inputValue()` function expects this position as the only mandatory
parameter. Parameter indices are 0-based; so the following code fragment
produces an extractor for this input parameter:

[source,scala]
----
val extCommand: CliExtractor[SingleOptionValue[String]] = inputValue(0)
----

Input parameters do not necessarily need a key like options; it is, however,
recommended defining one, as these keys appear in error or usage messages. If
the developer does not define a key, SCLI generates a synthetic key based on
the parameter index. To define a key explicitly, pass the _optKey_ parameter
to the function (it is an `Option`, which is `None` per default):

[source,scala]
----
val extCommand = inputValue(optKey = Some("transferCommand"), index = 0)
----

==== Extracting an input parameter with multiple values

To deal with input parameters with multiple values, there is the
`inputValues()` function. In contrast to `inputValue()`, it does not take a
single parameter index, but a pair of _fromIndex_ and _toIndex_. Like the
index parameter for `inputValue()`, these indices start with 0. Both are
inclusive. So if you want to assign the first three input values to a
parameter, you have to set the _fromIndex_ to 0 and the _toIndex_ to 2.

For the files to transfer in the sample application, we have the problem that
the exact number of parameter values is unknown; the user can provide an
arbitrary number of paths. So how to set the _toIndex_ parameter?

To deal with such use cases, there is the possibility to specify negative index
values. A negative index is interpreted from the end of the command line: The
index value -1 references the last input parameter; the index -2 the second
last, etc.

In the _transfer_ application, the list of files to transfer starts from the
second input value (after the transfer command) and goes to the one before the
last; the last one is the URI of the server. So the indices to specify are
_fromIndex_ = 1 and _toIndex_ = -2. Here is the code fragment that constructs
the extractor for the _transferFiles_ parameter:

[source,scala]
----
val extSrcFiles: CliExtractor[OptionValue[String]] =
  inputValues(fromIdx = 1, toIdx = -2, optKey = Some("transferFiles"))
----

Now for the last remaining input parameter, the server URI, we can use the same
trick. As it is the last parameter, we simply set the index to -1, resulting
in:

[source,scala]
----
val extServerUri = inputValue(optKey = Some("serverUri"), index = -1)
  .mandatory
----

==== Defining the multiplicity of parameters

There is still a problem with the definition of the input parameter for the
files to transfer: The current declaration states that the parameter values are
in the range from the second to the second last parameter value. This could
yield an empty list of values if the command line contains only the transfer
command and the server URI. The application logic, however, requires at least
one file to be present.

Single-valued parameters support the `mandatory` modifier to declare that a
value is required. For parameters with multiple values, there is a means
allowing even more control over the exact number of values supported: the
`multiplicity` modifier. The modifier takes up to two parameters for the
minimum and maximum number of parameter values. If a bound is unspecified, this
means that there is no restriction in this direction. The default multiplicity
assumed for a multi-valued parameter is `0..\*` - an arbitrary number of values
is allowed. For the _transferFiles_ parameter we have to change this to
`1..*`, so that at lest one value must be provided. To do this, we extend the
declaration of the parameter as in the following fragment:

[source,scala]
----
val extSrcFiles = inputValues(fromIdx = 1, toIdx = -2, optKey = Some("transferFiles"))
  .multiplicity(atLeast = 1)
----

Now the extractor generates a failure if no file to transfer has been passed
in.

NOTE: The `multiplicity` modifier has been introduced in the context of
input parameters; but it is supported by all kinds of parameters with multiple
values.

=== Type conversions

While the command line passed to an application is a list of strings, the
single parameter values may have different data types in the logic of the
applications. In the _transfer_ sample application, the list of files to
transfer should actually contain `java.nio.file.Path` objects; there is another
parameter to define a chunk size for the transfer, which is actually an integer
number.

SCLI supports a standard set of data type conversions for both extractors for
single-valued and multi-valued parameters. In addition, there is a mechanism
to apply arbitrary conversion functions.

Type conversions may fail. For instance, if the user passes the string _LARGE_
to the _chunkSize_ option, the conversion to `Int` will throw an exception.
Such exceptions are caught during parameter processing and recorded as failures
that can be displayed to the user.

==== Extracting an Int parameter

One of the conversion functions available out of the box is `toInt`. Like all
of these conversions, it is applicable to extractors yielding a String type.
The resulting extractor then produces a value of type `Int`.

The sample application, applies this conversion to the already mentioned
_chunkSize_ option:

[source,scala]
----
val extChunkSize: CliExtractor[SingleOptionValue[Int]] = optionValue("chunk-size")
  .toInt
----

==== Extracting a Path parameter

For the input parameter for the files to transfer, the values need to be
converted to `Path` objects. This is done analogously to the integer conversion
by using the `toPath` conversion function. (As you see, it does not make any
difference whether the extractor produces a single or multiple values; the
conversion functions are available in both cases.)

[source,scala]
----
val extSrcFiles: CliExtractor[OptionValue[Path]] =
  inputValues(fromIdx = 1, toIdx = -2, optKey = Some("transferFiles"))
    .multiplicity(atLeast = 1)
    .toPath
----

==== Extracting a Boolean parameter

Another conversion function available out of the box is `toBoolean`, which, not
surprisingly, converts parameter values to the type Boolean. It does this by
evaluating the string value and expecting one of the strings *true* or *false*;
result is the corresponding Boolean value, any other value causes the extractor
to produce a failure.

So this conversion function is rather restrictive. One way to make it more
lenient is allowing different case for the parameter values - so that input
like *True* or *FALSE* is still accepted. For such use cases, SCLI supports the
`toLower` function which converts the value(s) of a parameter to lower case.
This function can now be applied before the `toBoolean` conversion:

[source,scala]
----
val extBoolean: CliExtractor[SingleOptionValue[Boolean]] = optionValue("flag")
  .toLower
  .toBoolean
----

NOTE: An alternative to a type conversion to Boolean can be switches. Here the
presence or absence of the switch in the command line determines whether the
value is *true* or *false*. This can be more convenient for the user who is not
forced to enter the correctly spelled string values.

==== Extracting an enum parameter

Sometimes the value(s) of a parameter must belong to a defined set of allowed
constants. A possible use case is selecting a specific mode of the application.
The _transfer_ sample application supports a parameter to set the mode for
encrypting files during the transfer. Here multiple options are available:
Encryption can be disabled, the content of the files can be encrypted, or
encryption can be applied to both the content and the file names.

The conversion function to deal with such cases is `toEnum`. The function is
not limited to Java enum classes as the name might suggest. It rather expects a
mapping function, which converts the original string value to a target value.
The function actually returns an `Option` of the target value; a result of
`None` means, that the string value could not be matched to a valid enumeration
literal. This causes the extractor to produce a failure.

The _transfer_ application needs to map strings to constants of the `CryptMode`
class. `CryptMode` is actually a Scala enumeration class as shown below:

[source,scala]
----
object CryptMode extends Enumeration {

  val None, Files, FilesAndNames = Value

  final val Literals: Map[String, CryptMode.Value] =
    values.map(v => (v.toString.toUpperCase(Locale.ROOT), v)).toMap
  }
----

The class defines a number of constants representing the valid modes for
encryption. It also has a map allowing access to constants by their name; the
keys in this map are in upper case. The extractor for the encryption mode uses
this map for the mapping of input strings to `CryptMode` constants:

[source,scala]
----
private def cryptModeExtractor: CliExtractor[SingleOptionValue[CryptMode.Value]] =
  optionValue("crypt-mode")
    .toUpper
    .toEnum(CryptMode.Literals.get)
----

Note how the _get()_ function of the map with `CryptMode` literals is passed as
mapping function to the `toEnum` converter. `Map.get()` in this case is a
function of type `String => Option[CryptMode.Value]`, which is the exact
signature required by `toEnum`. This is a good example of the flexibility
allowed by the approach with the mapping function.

Note further the usage of the `toUpper` conversion function before applying
`toEnum`. `toUpper` is the counter-part of the `toLower` converter we already
met. It converts the current parameter value to upper case. This is needed in
this case because the keys in the map accessed by the mapping function are in
upper case as well.

==== Applying a custom mapping function

Extractors, being monads, support operations like _map()_ or _flatMap()_
natively to transform the values they produce. However, given the data types
the extractors typically operate on, using these operations is rather
inconvenient. The mapping functions expected by them have to deal with
Iterables or Options nested in Tries.

To simplify custom mapping, SCLI therefore offers the `mapTo` converter. It
expects a mapping function that directly operates on the option values. This
function is called only if the result of the extractor is successful, and a
value is actually present.

The _transfer_ sample application uses this feature to extract the `timeout`
option. The user can here specify an Int value, which is interpreted as the
timeout for a transfer operation in seconds. The data type of the value of
this option is `Option[Duration]` (as it is not required to provide a timeout).
The code fragment below shows the declaration of the extractor for the
`timeout` option. It converts the value of the option to the type `Int` first
and then applies a custom mapping function to transform the result to a
`Duration`:

[source,scala]
----
val extTimeout = optionValue("timeout")
  .toInt
  .mapTo(t => t.seconds)
----

=== Fallback values

It is often not necessary that the user provides each and every parameter on
the command line; the application can assume meaningful default or fallback
values for missing parameters. There are basically two approaches to handle
such missing parameters in SCLI:

The first approach is to model optional parameters as such. For instance, the
data classes representing the parameters supported by the application can have
properties of type `Option` or potentially empty collections for parameters
that are not mandatory. Because the base types of SCLI for parameter values
already support optional parameters, there is no additional work to do for the
developer; when evaluating the values extracted, they come out as `Option` or
collection types. This approach forces the application logic to deal with
missing parameters. For instance, when accessing an optional property the
application could use a `getOrElse` construct to inject a fallback value if
necessary.

The second approach is to provide such fallback values directly during the
processing of the command line. For this purpose, SCLI offers functions to
assign fallback values to processors. The logic of these functions is that if
the extractor produces a value, this value is used; otherwise, the fallback
value comes into play. When using this approach the application logic can
assume that parameter values are present. A drawback could be that the module
responsible for command line processing needs the knowledge about meaningful
default values.

SCLI is not opinionated about the approach chosen by a concrete application.
It is also no problem to mix these approaches, so that an application can
decide on a per parameter basis which variant is the most suitable one. This
subsection describes the second approach.

==== Specifying a single fallback value

Every extractor based on the `SingleOptionValue` type supports setting a
single fallback value, which of course must correspond to the concrete data
type of the value. It is set via the `fallbackValue()` function. The sample
_transfer_ application uses this mechanism to set a fallback value for the
`chunkSize` option:

[source,scala]
----
final val DefaultChunkSize = 8192

val extChunkSize = optionValue("chunk-size")
  .toInt
  .fallbackValue(DefaultChunkSize)
  .mandatory
----

Note that it is now safe to use the `mandatory` modifier at the end: with the
fallback value in place, it is guaranteed that the option has a value. The
result type of the extractor is now `Try[Int]`.

==== Specifying multiple fallback values

For extractors operating on the `OptionValue` type, you can specify multiple
fallback values. The function for this purpose is consequently named
`fallbackValues()`. It expects a mandatory parameter for the first fallback
value and then a varargs parameter for an arbitrary number of further values.

The sample application does not use this function. So let's for a moment
consider that we want to set some default log entries to be applied if the user
has not provided the `log` option. Then the declaration of the extractor could
look as follows:

[source,scala]
----
val extLog = multiOptionValue("log")
  .fallbackValues("Transfer log", "Update without a concrete log message")
----

==== Specifying a fallback extractor

Setting concrete fallback values is just a special case for running another
extractor if an extractor does not yield a value. This replacement extractor
can then execute arbitrary logic to compute a value for the parameter in
question. This mechanism is supported for both single-valued and multi-valued
extractors in form of the `fallback()` function. We will present an example of
using this function when we discuss password parameters.
